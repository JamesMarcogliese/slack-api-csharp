// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Slack.Api.CSharp.WebApi
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Chat operations.
    /// </summary>
    public partial class Chat : IServiceOperations<SlackWebAPI>, IChat
    {
        /// <summary>
        /// Initializes a new instance of the Chat class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public Chat(SlackWebAPI client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the SlackWebAPI
        /// </summary>
        public SlackWebAPI Client { get; private set; }

        /// <summary>
        /// Deletes a message.
        /// <see href="https://api.slack.com/methods/chat.delete" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `chat:write`
        /// </param>
        /// <param name='asUser'>
        /// Pass true to delete the message as the authed user with `chat:write:user`
        /// scope. [Bot users](/bot-users) in this context are considered authed users.
        /// If unused or false, the message will be deleted with `chat:write:bot`
        /// scope.
        /// </param>
        /// <param name='ts'>
        /// Timestamp of the message to be deleted.
        /// </param>
        /// <param name='channel'>
        /// Channel containing the message to be deleted.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="DeleteErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<DeleteOKResponse>> DeleteWithHttpMessagesAsync(string token = default(string), bool? asUser = default(bool?), double? ts = default(double?), string channel = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("asUser", asUser);
                tracingParameters.Add("ts", ts);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Delete", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.delete").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("token"))
                {
                    _httpRequest.Headers.Remove("token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            var values = new List<KeyValuePair<string, string>>();
            if(asUser != null)
            {
                values.Add(new KeyValuePair<string,string>("as_user", asUser.ToString()));
            }
            if(ts != null)
            {
                values.Add(new KeyValuePair<string,string>("ts", ts.ToString()));
            }
            if(channel != null)
            {
                values.Add(new KeyValuePair<string,string>("channel", channel));
            }
            var _formContent = new FormUrlEncodedContent(values);
            _httpRequest.Content = _formContent;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new DeleteErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    DeleteErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<DeleteErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<DeleteOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<DeleteOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Retrieve a permalink URL for a specific extant message
        /// <see href="https://api.slack.com/methods/chat.getPermalink" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `none`
        /// </param>
        /// <param name='messageTs'>
        /// A message's `ts` value, uniquely identifying it within a channel
        /// </param>
        /// <param name='channel'>
        /// The ID of the conversation or channel containing the message
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="GetPermalinkErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetPermalinkOKResponse>> GetPermalinkWithHttpMessagesAsync(string token = default(string), double? messageTs = default(double?), string channel = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("messageTs", messageTs);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetPermalink", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.getPermalink").ToString();
            List<string> _queryParameters = new List<string>();
            if (token != null)
            {
                _queryParameters.Add(string.Format("token={0}", System.Uri.EscapeDataString(token)));
            }
            if (messageTs != null)
            {
                _queryParameters.Add(string.Format("message_ts={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(messageTs, Client.SerializationSettings).Trim('"'))));
            }
            if (channel != null)
            {
                _queryParameters.Add(string.Format("channel={0}", System.Uri.EscapeDataString(channel)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new GetPermalinkErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    GetPermalinkErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GetPermalinkErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetPermalinkOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GetPermalinkOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Share a me message into a channel.
        /// <see href="https://api.slack.com/methods/chat.meMessage" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `chat:write:user`
        /// </param>
        /// <param name='text'>
        /// Text of the message to send.
        /// </param>
        /// <param name='channel'>
        /// Channel to send message to. Can be a public channel, private group or IM
        /// channel. Can be an encoded ID, or a name.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="MeMessageErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<MeMessageOKResponse>> MeMessageWithHttpMessagesAsync(string token = default(string), string text = default(string), string channel = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("text", text);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "MeMessage", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.meMessage").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("token"))
                {
                    _httpRequest.Headers.Remove("token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            var values = new List<KeyValuePair<string, string>>();
            if(text != null)
            {
                values.Add(new KeyValuePair<string,string>("text", text));
            }
            if(channel != null)
            {
                values.Add(new KeyValuePair<string,string>("channel", channel));
            }
            var _formContent = new FormUrlEncodedContent(values);
            _httpRequest.Content = _formContent;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new MeMessageErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    MeMessageErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<MeMessageErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<MeMessageOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<MeMessageOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Sends an ephemeral message to a user in a channel.
        /// <see href="https://api.slack.com/methods/chat.postEphemeral" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `chat:write`
        /// </param>
        /// <param name='attachments'>
        /// A JSON-based array of structured attachments, presented as a URL-encoded
        /// string.
        /// </param>
        /// <param name='text'>
        /// Text of the message to send. See below for an explanation of
        /// [formatting](#formatting). This field is usually required, unless you're
        /// providing only `attachments` instead.
        /// </param>
        /// <param name='linkNames'>
        /// Find and link channel names and usernames.
        /// </param>
        /// <param name='parse'>
        /// Change how messages are treated. Defaults to `none`. See
        /// [below](#formatting).
        /// </param>
        /// <param name='user'>
        /// `id` of the user who will receive the ephemeral message. The user should be
        /// in the channel specified by the `channel` argument.
        /// </param>
        /// <param name='asUser'>
        /// Pass true to post the message as the authed bot. Defaults to false.
        /// </param>
        /// <param name='channel'>
        /// Channel, private group, or IM channel to send message to. Can be an encoded
        /// ID, or a name.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="PostEphemeralErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<PostEphemeralOKResponse>> PostEphemeralWithHttpMessagesAsync(string token = default(string), string attachments = default(string), string text = default(string), bool? linkNames = default(bool?), string parse = default(string), string user = default(string), bool? asUser = default(bool?), string channel = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("attachments", attachments);
                tracingParameters.Add("text", text);
                tracingParameters.Add("linkNames", linkNames);
                tracingParameters.Add("parse", parse);
                tracingParameters.Add("user", user);
                tracingParameters.Add("asUser", asUser);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostEphemeral", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.postEphemeral").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("token"))
                {
                    _httpRequest.Headers.Remove("token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            var values = new List<KeyValuePair<string, string>>();
            if(attachments != null)
            {
                values.Add(new KeyValuePair<string,string>("attachments", attachments));
            }
            if(text != null)
            {
                values.Add(new KeyValuePair<string,string>("text", text));
            }
            if(linkNames != null)
            {
                values.Add(new KeyValuePair<string,string>("link_names", linkNames.ToString()));
            }
            if(parse != null)
            {
                values.Add(new KeyValuePair<string,string>("parse", parse));
            }
            if(user != null)
            {
                values.Add(new KeyValuePair<string,string>("user", user));
            }
            if(asUser != null)
            {
                values.Add(new KeyValuePair<string,string>("as_user", asUser.ToString()));
            }
            if(channel != null)
            {
                values.Add(new KeyValuePair<string,string>("channel", channel));
            }
            var _formContent = new FormUrlEncodedContent(values);
            _httpRequest.Content = _formContent;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new PostEphemeralErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    PostEphemeralErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PostEphemeralErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<PostEphemeralOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PostEphemeralOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Sends a message to a channel.
        /// <see href="https://api.slack.com/methods/chat.postMessage" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `chat:write`
        /// </param>
        /// <param name='username'>
        /// Set your bot's user name. Must be used in conjunction with `as_user` set to
        /// false, otherwise ignored. See [authorship](#authorship) below.
        /// </param>
        /// <param name='threadTs'>
        /// Provide another message's `ts` value to make this message a reply. Avoid
        /// using a reply's `ts` value; use its parent instead.
        /// </param>
        /// <param name='attachments'>
        /// A JSON-based array of structured attachments, presented as a URL-encoded
        /// string.
        /// </param>
        /// <param name='unfurlLinks'>
        /// Pass true to enable unfurling of primarily text-based content.
        /// </param>
        /// <param name='text'>
        /// Text of the message to send. See below for an explanation of
        /// [formatting](#formatting). This field is usually required, unless you're
        /// providing only `attachments` instead. Provide no more than 40,000
        /// characters or [risk
        /// truncation](/changelog/2018-04-truncating-really-long-messages).
        /// </param>
        /// <param name='unfurlMedia'>
        /// Pass false to disable unfurling of media content.
        /// </param>
        /// <param name='parse'>
        /// Change how messages are treated. Defaults to `none`. See
        /// [below](#formatting).
        /// </param>
        /// <param name='asUser'>
        /// Pass true to post the message as the authed user, instead of as a bot.
        /// Defaults to false. See [authorship](#authorship) below.
        /// </param>
        /// <param name='mrkdwn'>
        /// Disable Slack markup parsing by setting to `false`. Enabled by default.
        /// </param>
        /// <param name='iconEmoji'>
        /// Emoji to use as the icon for this message. Overrides `icon_url`. Must be
        /// used in conjunction with `as_user` set to `false`, otherwise ignored. See
        /// [authorship](#authorship) below.
        /// </param>
        /// <param name='linkNames'>
        /// Find and link channel names and usernames.
        /// </param>
        /// <param name='iconUrl'>
        /// URL to an image to use as the icon for this message. Must be used in
        /// conjunction with `as_user` set to false, otherwise ignored. See
        /// [authorship](#authorship) below.
        /// </param>
        /// <param name='channel'>
        /// Channel, private group, or IM channel to send message to. Can be an encoded
        /// ID, or a name. See [below](#channels) for more details.
        /// </param>
        /// <param name='replyBroadcast'>
        /// Used in conjunction with `thread_ts` and indicates whether reply should be
        /// made visible to everyone in the channel or conversation. Defaults to
        /// `false`.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="PostMessageErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<PostMessageOKResponse>> PostMessageWithHttpMessagesAsync(string token = default(string), string username = default(string), double? threadTs = default(double?), string attachments = default(string), bool? unfurlLinks = default(bool?), string text = default(string), bool? unfurlMedia = default(bool?), string parse = default(string), bool? asUser = default(bool?), bool? mrkdwn = default(bool?), string iconEmoji = default(string), bool? linkNames = default(bool?), string iconUrl = default(string), string channel = default(string), bool? replyBroadcast = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("username", username);
                tracingParameters.Add("threadTs", threadTs);
                tracingParameters.Add("attachments", attachments);
                tracingParameters.Add("unfurlLinks", unfurlLinks);
                tracingParameters.Add("text", text);
                tracingParameters.Add("unfurlMedia", unfurlMedia);
                tracingParameters.Add("parse", parse);
                tracingParameters.Add("asUser", asUser);
                tracingParameters.Add("mrkdwn", mrkdwn);
                tracingParameters.Add("iconEmoji", iconEmoji);
                tracingParameters.Add("linkNames", linkNames);
                tracingParameters.Add("iconUrl", iconUrl);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("replyBroadcast", replyBroadcast);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostMessage", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.postMessage").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("token"))
                {
                    _httpRequest.Headers.Remove("token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            var values = new List<KeyValuePair<string, string>>();
            if(username != null)
            {
                values.Add(new KeyValuePair<string,string>("username", username));
            }
            if(threadTs != null)
            {
                values.Add(new KeyValuePair<string,string>("thread_ts", threadTs.ToString()));
            }
            if(attachments != null)
            {
                values.Add(new KeyValuePair<string,string>("attachments", attachments));
            }
            if(unfurlLinks != null)
            {
                values.Add(new KeyValuePair<string,string>("unfurl_links", unfurlLinks.ToString()));
            }
            if(text != null)
            {
                values.Add(new KeyValuePair<string,string>("text", text));
            }
            if(unfurlMedia != null)
            {
                values.Add(new KeyValuePair<string,string>("unfurl_media", unfurlMedia.ToString()));
            }
            if(parse != null)
            {
                values.Add(new KeyValuePair<string,string>("parse", parse));
            }
            if(asUser != null)
            {
                values.Add(new KeyValuePair<string,string>("as_user", asUser.ToString()));
            }
            if(mrkdwn != null)
            {
                values.Add(new KeyValuePair<string,string>("mrkdwn", mrkdwn.ToString()));
            }
            if(iconEmoji != null)
            {
                values.Add(new KeyValuePair<string,string>("icon_emoji", iconEmoji));
            }
            if(linkNames != null)
            {
                values.Add(new KeyValuePair<string,string>("link_names", linkNames.ToString()));
            }
            if(iconUrl != null)
            {
                values.Add(new KeyValuePair<string,string>("icon_url", iconUrl));
            }
            if(channel != null)
            {
                values.Add(new KeyValuePair<string,string>("channel", channel));
            }
            if(replyBroadcast != null)
            {
                values.Add(new KeyValuePair<string,string>("reply_broadcast", replyBroadcast.ToString()));
            }
            var _formContent = new FormUrlEncodedContent(values);
            _httpRequest.Content = _formContent;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new PostMessageErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    PostMessageErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PostMessageErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<PostMessageOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PostMessageOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Provide custom unfurl behavior for user-posted URLs
        /// <see href="https://api.slack.com/methods/chat.unfurl" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `links:write`
        /// </param>
        /// <param name='userAuthMessage'>
        /// Provide a simply-formatted string to send as an ephemeral message to the
        /// user as invitation to authenticate further and enable full unfurling
        /// behavior
        /// </param>
        /// <param name='userAuthRequired'>
        /// Set to `true` or `1` to indicate the user must install your Slack app to
        /// trigger unfurls for this domain
        /// </param>
        /// <param name='unfurls'>
        /// URL-encoded JSON map with keys set to URLs featured in the the message,
        /// pointing to their unfurl message attachments.
        /// </param>
        /// <param name='ts'>
        /// Timestamp of the message to add unfurl behavior to.
        /// </param>
        /// <param name='userAuthUrl'>
        /// Send users to this custom URL where they will complete authentication in
        /// your app to fully trigger unfurling. Value should be properly URL-encoded.
        /// </param>
        /// <param name='channel'>
        /// Channel ID of the message
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="UnfurlErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<UnfurlOKResponse>> UnfurlWithHttpMessagesAsync(string token = default(string), string userAuthMessage = default(string), bool? userAuthRequired = default(bool?), string unfurls = default(string), string ts = default(string), string userAuthUrl = default(string), string channel = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("userAuthMessage", userAuthMessage);
                tracingParameters.Add("userAuthRequired", userAuthRequired);
                tracingParameters.Add("unfurls", unfurls);
                tracingParameters.Add("ts", ts);
                tracingParameters.Add("userAuthUrl", userAuthUrl);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Unfurl", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.unfurl").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("token"))
                {
                    _httpRequest.Headers.Remove("token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            var values = new List<KeyValuePair<string, string>>();
            if(userAuthMessage != null)
            {
                values.Add(new KeyValuePair<string,string>("user_auth_message", userAuthMessage));
            }
            if(userAuthRequired != null)
            {
                values.Add(new KeyValuePair<string,string>("user_auth_required", userAuthRequired.ToString()));
            }
            if(unfurls != null)
            {
                values.Add(new KeyValuePair<string,string>("unfurls", unfurls));
            }
            if(ts != null)
            {
                values.Add(new KeyValuePair<string,string>("ts", ts));
            }
            if(userAuthUrl != null)
            {
                values.Add(new KeyValuePair<string,string>("user_auth_url", userAuthUrl));
            }
            if(channel != null)
            {
                values.Add(new KeyValuePair<string,string>("channel", channel));
            }
            var _formContent = new FormUrlEncodedContent(values);
            _httpRequest.Content = _formContent;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new UnfurlErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    UnfurlErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<UnfurlErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<UnfurlOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<UnfurlOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Updates a message.
        /// <see href="https://api.slack.com/methods/chat.update" />
        /// </summary>
        /// <param name='token'>
        /// Authentication token. Requires scope: `chat:write`
        /// </param>
        /// <param name='attachments'>
        /// A JSON-based array of structured attachments, presented as a URL-encoded
        /// string. This field is required when not presenting `text`.
        /// </param>
        /// <param name='text'>
        /// New text for the message, using the [default formatting
        /// rules](/docs/formatting). It's not required when presenting `attachments`.
        /// </param>
        /// <param name='ts'>
        /// Timestamp of the message to be updated.
        /// </param>
        /// <param name='parse'>
        /// Change how messages are treated. Defaults to `client`, unlike
        /// `chat.postMessage`. See [below](#formatting).
        /// </param>
        /// <param name='asUser'>
        /// Pass true to update the message as the authed user. [Bot users](/bot-users)
        /// in this context are considered authed users.
        /// </param>
        /// <param name='linkNames'>
        /// Find and link channel names and usernames. Defaults to `none`. See
        /// [below](#formatting).
        /// </param>
        /// <param name='channel'>
        /// Channel containing the message to be updated.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="UpdateErrorModelException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<UpdateOKResponse>> UpdateWithHttpMessagesAsync(string token = default(string), string attachments = default(string), string text = default(string), double? ts = default(double?), string parse = default(string), bool? asUser = default(bool?), bool? linkNames = default(bool?), string channel = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("token", token);
                tracingParameters.Add("attachments", attachments);
                tracingParameters.Add("text", text);
                tracingParameters.Add("ts", ts);
                tracingParameters.Add("parse", parse);
                tracingParameters.Add("asUser", asUser);
                tracingParameters.Add("linkNames", linkNames);
                tracingParameters.Add("channel", channel);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "Update", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "chat.update").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("token"))
                {
                    _httpRequest.Headers.Remove("token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            var values = new List<KeyValuePair<string, string>>();
            if(attachments != null)
            {
                values.Add(new KeyValuePair<string,string>("attachments", attachments));
            }
            if(text != null)
            {
                values.Add(new KeyValuePair<string,string>("text", text));
            }
            if(ts != null)
            {
                values.Add(new KeyValuePair<string,string>("ts", ts.ToString()));
            }
            if(parse != null)
            {
                values.Add(new KeyValuePair<string,string>("parse", parse));
            }
            if(asUser != null)
            {
                values.Add(new KeyValuePair<string,string>("as_user", asUser.ToString()));
            }
            if(linkNames != null)
            {
                values.Add(new KeyValuePair<string,string>("link_names", linkNames.ToString()));
            }
            if(channel != null)
            {
                values.Add(new KeyValuePair<string,string>("channel", channel));
            }
            var _formContent = new FormUrlEncodedContent(values);
            _httpRequest.Content = _formContent;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new UpdateErrorModelException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    UpdateErrorModel _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<UpdateErrorModel>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<UpdateOKResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<UpdateOKResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
